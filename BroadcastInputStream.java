package org.apache.commons.io;

import java.io.InputStream;
import java.io.IOException;

/** LICENSE - this is provided under the terms of the Apache 2.0 license - see https://spdx.org/licenses/Apache-2.0.html */

/** Reads a single InputStream and broadcasts it to 1..N BroadcastConsumers. Each BroadcastConsumer will
 *  receive a copy of the entire original InputStream. Note that mark() and reset() are not supported.
 *
 *  An efficient alternative to setting up multiple PipeOutputStream/PipedInputStream connections, even if
 *  only broadcasting to 1 consumer. Internal buffer space is shared among all consumers, and full synchronization
 *  is required only when buffers are switched - instead of synchronizing the read and write of each byte.
 *
 *  Normally each of the BroadcastConsumers will execute in a separate thread in order to allow parallel
 *  processing of the data. Fast BroadcastConsumers (for example, in memory processing) may be throttled
 *  until slower consumers (for example, writing to an external device) catch up.
 *
 *  This also implies that if any BroadcastConsumer terminates abnormally, without closing itself,
 *  then all other consumers may enter an indefinite wait since the shared buffers are never released.
 *
 *  Once instantiated, the run() method of the BroadcastInputStream starts reading the original input and
 *  broadcasting to all of the consumers. The BroadcastInputStream may also be executed in a separate thread.
 *
 *  Example: Reading a large XML document generated by a sub-process, where the XML must be parsed, written to an
 *           output file, and also used to compute a word-frequency table.
 *
 *           A BroadcastInputstream with 3 BroadcastConsumers allows parallel processes - one to parse the XML,
 *           another to write it to a file, and a third to compute the word-frequencies - for minimal overall
 *           elapsed time and buffer space.
 *
 * Alternate constructors may specify the size and number of internal buffers.
 *
 * The overall structure is thread-safe, but the read() methods of the BroadcastConsumer instances are NOT
 * thread-safe. If processed in parallel, each BroadcastConsumer should be processed within a single thread.
 *
 * Note: run() cannot be listed as throwing an exception, so check hadError() to determine if any exception
 *       was thrown during processing. If true, use getError to retrieve. These methods also exist on each
 *       of the BroadcastConsumer instances to pick up any such Exception (except IOException on read()).
 *
 * @Author John Crowley Jan 2020
 */
public class BroadcastInputStream implements Runnable {
  // Some debug flags
  static final boolean     bDebug  = false;     // If 'false' debug code not generated into the Class
  boolean                  userDebug = false;   // Caller may specify through the Constructor

  private Exception        wasThrown = null;

  public final String      label;
  public final long        started = System.currentTimeMillis();
  public long              finishedRead = -1;      // Set when EOF on original input stream
  public long              finishedConsumers = -1; // Set when last BroadcastConsumer closes
  public final InputStream strm;
  private boolean          isOpen = true;
  private int              numOpenConsumers;       // Decremented when each is closed()
  private long             numWaits = 0;
  private long             ttlReads = 0;           // Each read is for 1 byte of data

  public final int         bufferSize;
  public final int         numBuffers;
  public final int         waitMillis;

  private final int        traceEvery;

  private long             threadID = -1;

  private BroadcastBuffer freeBuffers;   // Buffers available to read input from 'strm'
  private BroadcastBuffer inUseFirst;    // A chain of buffers with data, in order from first
  private BroadcastBuffer inUseLast;     // .. to last. New filled buffers added to the end
                                         // NOTE: inUseFirst will never be null. Will always have at least
                                         //       one buffer in the chain, even if a dummy.

  private BroadcastConsumer[] streams;    // The N consumer input streams provided to downstream readers

  /**
   *
   * @param label               - a name for this BroadcastInputStream, used only in getReport and debug output
   * @param strmIn              - original InputStream which should be broadcast
   * @param numberOfConsumers   - how many consumers to create (at least 1)
   * @param bufferSize          - size of each buffer (at least 256, suggest 2048, 4096, 8192, or higher)
   *                              Larger buffers minimize synchronization overhead but may reduce parallelism waiting
   *                              for the next internal input buffer to fill.
   * @param numberOfBuffers     - how many buffers to use - must be 2 or more - should be 8+ for better performance
   * @param threadWaitMillis    - how long to wait this Thread before checking if more data is available
   * @param labels              - an array of labels to assign to the BroadcastConsumers. If number of labels is empty
   *                              or fewer provided than numberOfConsumers, will be assigned 'A', 'B', 'C', ...
   * @param userDebug           - if True, prints debug info on construction, run() invoked, and close of each consumer
   * @param traceEvery          - 0 == nothing, else prints debug line for every N (> 0) input bytes read from strmIn
   */
  public BroadcastInputStream(String label, InputStream strmIn, int numberOfConsumers, int bufferSize, int numberOfBuffers, int threadWaitMillis, String[] labels, boolean userDebug, int traceEvery) throws IllegalArgumentException{
    this.label        = label;
    this.strm         = strmIn;
    this.numOpenConsumers = numberOfConsumers;
    this.bufferSize   = bufferSize;
    this.numBuffers   = numberOfBuffers;
    this.waitMillis   = threadWaitMillis;
    this.userDebug    = userDebug;
    this.traceEvery   = traceEvery;

    if(numBuffers < 2)    throw new IllegalArgumentException("Must have at least 2 buffers, had: " + numBuffers);
    if(numOpenConsumers < 1)   throw new IllegalArgumentException("Must have at least 1 BroadcastConsumer, had: " + numOpenConsumers);
    if(bufferSize < 256)  throw new IllegalArgumentException("Buffer size must be at least 256, had: " + bufferSize);
    if(waitMillis < 1)    throw new IllegalArgumentException("Thread wait millis must be at least 1, had: " + waitMillis);

    // Create the pool of N free buffers
    for(int i = 0; i < numBuffers; i++) {
      BroadcastBuffer bfr = new BroadcastBuffer(bufferSize);
      bfr.numOpen   = numberOfConsumers;
      bfr.next      = freeBuffers;
      freeBuffers   = bfr;
    }

    // Setup a dummy buffer in the inUse chain, with zero bytes, so all of the
    // BroadcastConsumer instances see this and start following the chain.
    inUseFirst = inUseLast = freeBuffers;
    freeBuffers            = freeBuffers.next;
    inUseFirst.amtPresent  = 0;
    inUseFirst.next        = null;

    streams = new BroadcastConsumer[numberOfConsumers];
    for(int i = 0; i < numberOfConsumers; i++) {
      String lbl = "";
      if(labels.length <= i) {
        int lblIndex = i % 26;
        int lblCount = lblIndex / 26;
        lbl = Character.toString("ABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(lblIndex));
        while(lblCount > 0) { lbl += lbl; lblCount--; }
      } else
        lbl = labels[i];

      streams[i] = new BroadcastConsumer(this, lbl, inUseFirst);
    }
    if(userDebug) {
      debug("BroadcastConsumer constructor for " + label + ", with " + numOpenConsumers + " consumers");
    }
  }
  /** Create with defaults: buffer size = 2048, 12 buffers, 50 millisecond wait time
   *
   * @param strmIn              - original InputStream which should be broadcast
   * @param numberOfConsumers  - how many consumers to create
   */
  public BroadcastInputStream(String label, InputStream strmIn, int numberOfConsumers, boolean userDebug, int traceEvery) throws IllegalArgumentException {
    this(label, strmIn, numberOfConsumers, 2048, 12, 5, new String[0], userDebug, traceEvery );
  }
  /** Create with defaults: buffer size = 2048, 12 buffers, 50 millisecond wait time, no debug output
   *
   * @param strmIn             - original InputStream which should be broadcast
   * @param numberOfConsumers  - how many consumers to create
   */
  public BroadcastInputStream(String label, InputStream strmIn, int numberOfConsumers) throws IllegalArgumentException {
    this(label, strmIn, numberOfConsumers, 2048, 12, 5, new String[0], false, 0);
  }

  /** Determine if all consumers have been completed OR this base was explicitly closed */
  public boolean isFinished()     { return !isOpen; }
  /** Determine if any internal error occurred during processing */
  public boolean hadError()       { return wasThrown!=null; }
  /** Return any exception thrown internally during processing. If NULL then no errors. */
  public Exception getError()     { return wasThrown; }

  /** Actual execution, starts reading the base InputStream, will block if no free buffers are available.
   *  May be executed in either the main thread or a separate thread.
   */
  @Override
  public void run() {
    threadID = Thread.currentThread().getId();
    if(userDebug){ debug("BroadcaseInputStream " + label + " run() invoked. ThreadID: " + threadID + (isOpen ? " isOpen = true" : " isOpen = FALSE")); }
    // Outer loop deals with buffers, inner loop fills one buffer
    while(isOpen) try {
      BroadcastBuffer bfr = getFreeBuffer();
      if (bfr != null) {
        int indx = 0;
        while (indx < bufferSize && isOpen) {
          int rd = strm.read();
          bfr.data[indx++] = rd;
          ttlReads++;
          if(traceEvery > 0){
            if((ttlReads % traceEvery) == 0)
              debug("BroadcastInputStream " + label + " read " + String.format("%,d", ttlReads) + " bytes");
          }
          if (rd == -1) {
            ttlReads--;
            strm.close();
            isOpen = false;
            freeBuffers = null;       // Release all the other buffers, won't need any more
            finishedRead = System.currentTimeMillis();
            if(userDebug) debug("BroadcastInputStream " + label + " got -1 -- Closing, " + indx + " in buffer");
          }
        }
        bfr.amtPresent = indx;
        // Add to the end of the in-use buffer chain
        synchronized(this) {
          inUseLast.next = bfr;
          inUseLast      = bfr;
        }
      } else {
        // Must wait until the consumers all finish with a buffer so it can be refilled
        numWaits++;
        Thread.sleep(waitMillis);
      }
    } catch(Exception ex) {
      isOpen = false;
      wasThrown = ex;
    }
  }

  public BroadcastConsumer[] getConsumers() { return streams; }

  public BroadcastConsumer getConsumer(int i) {
    return streams[i];
  }

  // Mark this buffer as closed by one consumer and return reference to the next input buffer, NULL if none
  // Note: The consumers check whether bfr.next is non-null before calling this method, which avoids
  //       the overhead of a full synchronization until a next buffer is available.
  synchronized BroadcastBuffer finishedWithBuffer(BroadcastBuffer bfr, String lbl) {
    BroadcastBuffer bfrNext = null;
    if(bfr!=null){
      bfrNext = bfr.next;
      bfr.numOpen--;
      if (bfr.numOpen <= 0) {         // All of the consumers are finished with this buffer
        inUseFirst = inUseFirst==null ? null : inUseFirst.next;
        if(isOpen) {                  // Add to list of free buffers unless already hit EOF
          bfr.next = freeBuffers;
          freeBuffers = bfr;
        }
      }
    }
    return bfrNext;
  }

  /** If any of the consumers is closed, must reduce the 'open' count for all in-use buffers.
   *  If ALL of the consumers have been closed, then close the input stream.
   */
  synchronized void closeConsumer() throws IOException {
    numOpenConsumers--;
    if(numOpenConsumers == 0) {
      finishedConsumers = System.currentTimeMillis();
      if(isOpen) {
        strm.close();
        isOpen = false;
      }
    } else {
      BroadcastBuffer bfr = inUseFirst;
      while (bfr != null) {
        bfr.numOpen--;
        bfr = bfr.next;
      }
    }
  }
  /** Close called for the entire InputStream */
  synchronized public void close() throws IOException {
    if(isOpen) for(BroadcastConsumer strm: streams) strm.close();
  }

  // Get (and initialize) the next free buffer - returns null if no free buffer available
  synchronized private BroadcastBuffer getFreeBuffer() {
    BroadcastBuffer bfr = null;
    if(freeBuffers != null) {
      bfr         = freeBuffers;
      freeBuffers = freeBuffers.next;
      bfr.next    = null;
      bfr.numOpen = numOpenConsumers;
    }
    return bfr;
  }

  synchronized int available(BroadcastBuffer bfr, int indx) throws IOException {
    int rslt = bfr.amtPresent - indx;
    BroadcastBuffer next = bfr.next;
    while(next != null){
      rslt += next.amtPresent;
      next = next.next;
    }

    return rslt + strm.available();
  }

  public int getNumberOfOpenConsumers()  { return numOpenConsumers; }
  public int getNumberOfConsumers()      { return streams.length; }
  /** Get total elapsed time to read original (source) input stream. Returns -1 if still in process */
  public long getOriginalReadMillis()    { return finishedRead < 0 ? -1 : finishedRead - started; }
  /** Get the total time for ALL of the consumers to finish reading all data (or close early). Returns -1 if still in process
   *  Note: See BroadcastConsumer.getElapsedMillis to get time for a particular consumer.
   */
  public long getAllElapsedMillis()      { return finishedConsumers < 0 ? -1 : finishedConsumers - started; }
  /** Get the total time waiting to read original data */
  public long getTotalWait()             { return numWaits * waitMillis; }
  /** Get the total amount of data read. Note: Same will be read by each consumer unless it closes itself early */
  public long getTotalData()             { return ttlReads; }
  /** Get the total amount of time waiting by ALL of the consumers */
  public long getTotalConsumerWait() {
    long ttlConWait = 0;
    for(BroadcastConsumer con: streams) ttlConWait += con.getTotalWait();
    return ttlConWait;
  }
  /** Get total data read by all consumeers - NOTE: May be squirrely if not all are yet closed. */
  public long getTotalConsumerRead() {
    long ttl = 0;
    for(BroadcastConsumer con: streams) ttl += con.getTotalReads();
    return ttl;
  }
  public String getReport()  {
    return String.format("BroadcastConsumer %1$s -- ThreadID: %14$d, Open: %2$b, TtlData: %3$,d, ReadElapsedMillis: %4$,d, TtlReadWait: %5$,d, Consumers -- Num: %6$,d, NumOpen: %7$,d, TtlWaitAll: %8$,d, TtlElapsed: %9$,d, TtlRead: %10$,d (%11$,d per consumer), NumBfrs: %12$,d BfrSz: %13$,d",
            label, isOpen, getTotalData(), getOriginalReadMillis(), getTotalWait(), getNumberOfConsumers(), getNumberOfOpenConsumers(), getTotalConsumerWait(), getAllElapsedMillis(), getTotalConsumerRead(), getTotalConsumerRead()/ getNumberOfConsumers(), numBuffers, bufferSize, getThreadID() );
  }
  public String getReportDetailed(){
    String s = " ";
    int indx = 0;
    for(BroadcastConsumer con:streams){ s += con.getReport(indx++); }
    return getReport() + s;
  }
  /** get the ID of the thread for the run() method. -1 if run() not yet started. */
  public long getThreadID() { return threadID; }

  void debug(String s) { ln("DEBUG: " + s);}

  void ln(String s){
    if(bDebug) System.out.println(s);
  }
}
